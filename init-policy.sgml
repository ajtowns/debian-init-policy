<!doctype debiandoc system [
<!entity % versiondata SYSTEM "version.ent"> %versiondata;
<!entity changesversion "1.8">
]>
<debiandoc>
<book>
  <titlepag>
    <title>Debian Init Policy Manual</title>
    <author>The Debian Policy Mailing List</author>
    <version>version &version;, &date;</version>

    <abstract>
      This manual describes the policy requirements for init systems
      and init scripts within the Debian distirbution.
    </abstract>

    <copyright>See the Debian Policy manual</copyright>

  </titlepag>

  <toc detail="sect1">

  <chapt id="admin">
    <heading>Managing Daemons on a Debian System</heading>
    <sect id="startstop">
      <heading>Starting and stopping a daemon</heading>
    </sect>
    <sect id="enabledisable">
      <heading>Enabling and disabling a daemon</heading>
    </sect>
    <sect id="policyrcd">
      <heading>Using policy-rc.d to set daemon policy</heading>
    </sect>
  </chapt>

  <chapt id="daemonmaint">
    <heading>Maintaining a Daemon</heading>
    <sect id="background">
      <heading>Background</heading>
          <p>
            There are at least two different, yet functionally
            equivalent, ways of handling these scripts.  For the sake
            of simplicity, this document describes only the symbolic
            link method. However, it must not be assumed by maintainer
            scripts that this method is being used, and any automated
            manipulation of the various runlevel behaviors by
            maintainer scripts must be performed using
            <prgn>update-rc.d</prgn> as described below and not by
            manually installing or removing symlinks.  For information
            on the implementation details of the other method,
            implemented in the <tt>file-rc</tt> package, please refer
            to the documentation of that package.
	  </p>
    </sect>

    <sect id="init.d">
      <heading>init.d scripts</heading>
	  <p>
	    The <file>/etc/init.d</file> directory contains the scripts
	    executed by <prgn>init</prgn> at boot time and when the
	    init state (or "runlevel") is changed (see <manref
	    name="init" section="8">).
	  </p>

	  <p>
	    Packages that include daemons for system services should
	    place scripts in <file>/etc/init.d</file> to start or stop
	    services at boot time or during a change of runlevel.
	    These scripts should be named
	    <file>/etc/init.d/<var>package</var></file>.
          </p>

        <sect1>
          <heading>Arguments for init.d scripts</heading>
          <p>Scripts in init.d should
	    accept one argument, saying what to do:

	    <taglist>
	      <tag><tt>start</tt></tag>
	      <item>start the service,</item>

	      <tag><tt>stop</tt></tag>
	      <item>stop the service,</item>

	      <tag><tt>restart</tt></tag>
	      <item>stop and restart the service if it's already running,
		  otherwise start the service</item>

	      <tag><tt>reload</tt></tag>
	      <item><p>cause the configuration of the service to be
		  reloaded without actually stopping and restarting
		  the service,</item>

	      <tag><tt>force-reload</tt></tag>
	      <item>cause the configuration to be reloaded if the
		  service supports this, otherwise restart the
		  service.</item>
	    </taglist>

	    The <tt>start</tt>, <tt>stop</tt>, <tt>restart</tt>, and
	    <tt>force-reload</tt> options should be supported by all
	    scripts in <file>/etc/init.d</file>, the <tt>reload</tt>
	    option is optional.
	  </p>

	  <p>
	    The <file>init.d</file> scripts must ensure that they will
	    behave sensibly (i.e., returning success and not starting
	    multiple copies of a service) if invoked with <tt>start</tt>
	    when the service is already running, or with <tt>stop</tt>
	    when it isn't, and that they don't kill unfortunately-named
	    user processes.  The best way to achieve this is usually to
	    use <prgn>start-stop-daemon</prgn> with the <tt>--oknodo</tt>
	    option.
	  </p>

	  <p>
	    If a service reloads its configuration automatically (as
	    in the case of <prgn>cron</prgn>, for example), the
	    <tt>reload</tt> option of the <file>init.d</file> script
	    should behave as if the configuration has been reloaded
	    successfully.
	  </p>
         </sect1>

         <sect1>
           <heading>Environment and customisations</heading>

	  <p>
	    Often there are some variables in the <file>init.d</file>
	    scripts whose values control the behavior of the scripts,
	    and which a system administrator is likely to want to
	    change.  As the scripts themselves are frequently
	    <tt>conffile</tt>s, modifying them requires that the
	    administrator merge in their changes each time the package
	    is upgraded and the <tt>conffile</tt> changes.  To ease
	    the burden on the system administrator, such configurable
	    values should not be placed directly in the script.
	    Instead, they should be placed in a file in
	    <file>/etc/default</file>, which typically will have the same
	    base name as the <file>init.d</file> script.  This extra file
	    should be sourced by the script when the script runs.  It
	    must contain only variable settings and comments in SUSv3
	    <prgn>sh</prgn> format.  It may either be a
	    <tt>conffile</tt> or a configuration file maintained by
	    the package maintainer scripts.  See <url id="https://www.debian.org/doc/debian-policy/ch-files.html#s-config-files" name="Configuration files">
	    for more details.
	  </p>

	  <p>
	    To ensure that vital configurable values are always
	    available, the <file>init.d</file> script should set default
	    values for each of the shell variables it uses, either
	    before sourcing the <file>/etc/default/</file> file or
	    afterwards using something like the <tt>:
	    ${VAR:=default}</tt> syntax.  Also, the <file>init.d</file>
	    script must behave sensibly and not fail if the
	    <file>/etc/default</file> file is deleted.
	  </p>
         </sect1>

         <sect1>
          <heading>Invocation and registration</heading>
          	  <p>
	    Maintainers should use the abstraction layer provided by
	    the <prgn>update-rc.d</prgn> and <prgn>invoke-rc.d</prgn>
	    programs to deal with initscripts in their packages'
	    scripts such as <prgn>postinst</prgn>, <prgn>prerm</prgn>
	    and <prgn>postrm</prgn>.
	  </p>

	  <p>
	    Directly managing the /etc/rc?.d links and directly
	    invoking the <file>/etc/init.d/</file> initscripts should
	    be done only by packages providing the initscript
	    subsystem (such as <prgn>sysv-rc</prgn> and
	    <prgn>file-rc</prgn>).
	  </p>

	  <sect2>
	    <heading>Managing the links</heading>

	    <p>
	      The program <prgn>update-rc.d</prgn> is provided for
	      package maintainers to arrange for the proper creation and
	      removal of <file>/etc/rc<var>n</var>.d</file> symbolic links,
	      or their functional equivalent if another method is being
	      used.  This may be used by maintainers in their packages'
	      <prgn>postinst</prgn> and <prgn>postrm</prgn> scripts.
	    </p>

	    <p>
	      You must not include any <file>/etc/rc<var>n</var>.d</file>
	      symbolic links in the actual archive or manually create or
	      remove the symbolic links in maintainer scripts; you must
	      use the <prgn>update-rc.d</prgn> program instead.  (The
	      former will fail if an alternative method of maintaining
	      runlevel information is being used.)  You must not include
	      the <file>/etc/rc<var>n</var>.d</file> directories themselves
	      in the archive either.  (Only the <tt>sysvinit</tt>
	      package may do so.)
	    </p>

	    <p>
	      By default <prgn>update-rc.d</prgn> will start services in
	      each of the multi-user state runlevels (2, 3, 4, and 5)
	      and stop them in the halt runlevel (0), the single-user
	      runlevel (1) and the reboot runlevel (6).  The system
	      administrator will have the opportunity to customize
	      runlevels by simply adding, moving, or removing the
	      symbolic links in <file>/etc/rc<var>n</var>.d</file> if
	      symbolic links are being used, or by modifying
	      <file>/etc/runlevel.conf</file> if the <tt>file-rc</tt> method
	      is being used.
	    </p>

	    <p>
	      To get the default behavior for your package, put in your
	      <prgn>postinst</prgn> script
	      <example compact="compact">
		update-rc.d <var>package</var> defaults
	      </example>
	      and in your <prgn>postrm</prgn>
	      <example compact="compact">
		if [ "$1" = purge ]; then
		update-rc.d <var>package</var> remove
		fi
	      </example>. Note that if your package changes runlevels
	      or priority, you may have to remove and recreate the links,
	      since otherwise the old links may persist. Refer to the
	      documentation of <prgn>update-rc.d</prgn>.
	    </p>

	    <p>
	      This will use a default sequence number of 20.  If it does
	      not matter when or in which order the <file>init.d</file>
	      script is run, use this default.  If it does, then you
	      should talk to the maintainer of the <prgn>sysvinit</prgn>
	      package or post to <tt>debian-devel</tt>, and they will
	      help you choose a number.
	    </p>

	    <p>
	      For more information about using <tt>update-rc.d</tt>,
	      please consult its man page <manref name="update-rc.d"
		section="8">.
	    </p>
	  </sect2>

	  <sect2>
	    <heading>Running initscripts</heading>
	    <p>
	      The program <prgn>invoke-rc.d</prgn> is provided to make
	      it easier for package maintainers to properly invoke an
	      initscript, obeying runlevel and other locally-defined
	      constraints that might limit a package's right to start,
	      stop and otherwise manage services. This program may be
	      used by maintainers in their packages' scripts.
	    </p>

	    <p>
	      The package maintainer scripts must use
	      <prgn>invoke-rc.d</prgn> to invoke the
	      <file>/etc/init.d/*</file> initscripts, instead of
	      calling them directly.
	    </p>

	    <p>
	      By default, <prgn>invoke-rc.d</prgn> will pass any
	      action requests (start, stop, reload, restart...) to the
	      <file>/etc/init.d</file> script, filtering out requests
	      to start or restart a service out of its intended
	      runlevels.
	    </p>

	    <p>
	      Most packages will simply need to change:
	      <example compact="compact">/etc/init.d/&lt;package&gt;
	      &lt;action&gt;</example> in their <prgn>postinst</prgn>
	      and <prgn>prerm</prgn> scripts to:
	      <example compact="compact">
	if which invoke-rc.d >/dev/null 2>&1; then
		invoke-rc.d <var>package</var> &lt;action&gt;
	else
		/etc/init.d/<var>package</var> &lt;action&gt;
	fi
	      </example>
	    </p>

	    <p>
	      A package should register its initscript services using
	      <prgn>update-rc.d</prgn> before it tries to invoke them
	      using <prgn>invoke-rc.d</prgn>. Invocation of
	      unregistered services may fail.
	    </p>

	    <p>
	      For more information about using
	      <prgn>invoke-rc.d</prgn>, please consult its man page
	      <manref name="invoke-rc.d" section="8">.
	    </p>
	  </sect2>
        </sect1>

        <sect1>
	<heading>Console messages from <file>init.d</file> scripts</heading>

	<p>
	  This section describes the formats to be used for messages
	  written to standard output by the <file>/etc/init.d</file>
	  scripts.  The intent is to improve the consistency of
	  Debian's startup and shutdown look and feel.  For this
	  reason, please look very carefully at the details.  We want
	  the messages to have the same format in terms of wording,
	  spaces, punctuation and case of letters.
	</p>

	<p>
	  Here is a list of overall rules that should be used for
	  messages generated by <file>/etc/init.d</file> scripts.  
	</p>

	<p>
	  <list>
	    <item>
		The message should fit in one line (fewer than 80
		characters), start with a capital letter and end with
		a period (<tt>.</tt>) and line feed (<tt>"\n"</tt>).
	    </item>

	    <item>
              If the script is performing some time consuming task in
              the background (not merely starting or stopping a
              program, for instance), an ellipsis (three dots:
              <tt>...</tt>) should be output to the screen, with no
              leading or tailing whitespace or line feeds.
	    </item>

	    <item>
              The messages should appear as if the computer is telling
              the user what it is doing (politely :-), but should not
                mention "it" directly.  For example, instead of:
		<example compact="compact">
I'm starting network daemons: nfsd mountd.
		</example>
		the message should say
		<example compact="compact">
Starting network daemons: nfsd mountd.
		</example>
	    </item>
	  </list>
	</p>

	<p>
          <tt>init.d</tt> script should use the following  standard
          message formats for the situations enumerated below.
	</p>

	<p>
	  <list>
	    <item>
	      <p>When daemons are started</p>

	      <p>
		If the script starts one or more daemons, the output
		should look like this (a single line, no leading
		spaces):
		<example compact="compact">
Starting <var>description</var>: <var>daemon-1</var> ... <var>daemon-n</var>.
		</example>
		The <var>description</var> should describe the
		subsystem the daemon or set of daemons are part of,
		while <var>daemon-1</var> up to <var>daemon-n</var>
		denote each daemon's name (typically the file name of
		the program).
	      </p>

	      <p>
		For example, the output of <file>/etc/init.d/lpd</file>
		would look like:
		<example compact="compact">
Starting printer spooler: lpd.
		</example>
	      </p>

	      <p>
		This can be achieved by saying
		<example compact="compact">
echo -n "Starting printer spooler: lpd"
start-stop-daemon --start --quiet --exec /usr/sbin/lpd
echo "."
		</example>
		in the script. If there are more than one daemon to
		start, the output should look like this:
		<example compact="compact">
echo -n "Starting remote file system services:"
echo -n " nfsd"; start-stop-daemon --start --quiet nfsd
echo -n " mountd"; start-stop-daemon --start --quiet mountd
echo -n " ugidd"; start-stop-daemon --start --quiet ugidd
echo "."
		</example>
		This makes it possible for the user to see what is
		happening and when the final daemon has been started.
		Care should be taken in the placement of white spaces:
		in the example above the system administrators can
		easily comment out a line if they don't want to start
		a specific daemon, while the displayed message still
		looks good.
	      </p>
	    </item>

	    <item>
	      <p>When a system parameter is being set</p>

	      <p>
		If you have to set up different system parameters
		during the system boot, you should use this format:
		<example compact="compact">
Setting <var>parameter</var> to "<var>value</var>".
		</example>
	      </p>

	      <p>
		You can use a statement such as the following to get
		the quotes right:
		<example compact="compact">
echo "Setting DNS domainname to \"$domainname\"."
		</example>
	      </p>

	      <p>
                Note that the same symbol (<tt>"</tt>) <!-- " --> is used
                for the left and right quotation marks.  A grave accent
                (<tt>`</tt>) is not a quote character; neither is an
                apostrophe (<tt>'</tt>).
	      </p>
	    </item>

	    <item>
	      <p>When a daemon is stopped or restarted</p>

	      <p>
		When you stop or restart a daemon, you should issue a
		message identical to the startup message, except that
		<tt>Starting</tt> is replaced with <tt>Stopping</tt>
		or <tt>Restarting</tt> respectively.
	      </p>

	      <p>
		For example, stopping the printer daemon will look like
		this:
		<example compact="compact">
Stopping printer spooler: lpd.
		</example>
	      </p>
	    </item>

	    <item>
	      <p>When something is executed</p>

	      <p>
		There are several examples where you have to run a
		program at system startup or shutdown to perform a
		specific task, for example, setting the system's clock
		using <prgn>netdate</prgn> or killing all processes
		when the system shuts down.  Your message should look
		like this:
		<example compact="compact">
Doing something very useful...done.
		</example>
		You should print the <tt>done.</tt> immediately after
		the job has been completed, so that the user is
		informed why they have to wait.  You can get this
		behavior by saying
		<example compact="compact">
echo -n "Doing something very useful..."
do_something
echo "done."
		</example>
		in your script.
	      </p>
	    </item>

	    <item>
	      <p>When the configuration is reloaded</p>

	      <p>
		When a daemon is forced to reload its configuration
		files you should use the following format:
		<example compact="compact">
Reloading <var>description</var> configuration...done.
		</example>
		where <var>description</var> is the same as in the
		daemon starting message.
	      </p>
	    </item>
	  </list>
	</p>
         </sect1>


         <sect1>
          <heading>Miscellaneous Notes</heading>
	  <p>
	    Be careful of using <tt>set -e</tt> in <file>init.d</file>
	    scripts.  Writing correct <file>init.d</file> scripts requires
	    accepting various error exit statuses when daemons are already
	    running or already stopped without aborting
	    the <file>init.d</file> script, and common <file>init.d</file>
	    function libraries are not safe to call with <tt>set -e</tt>
	    in effect<footnote>
	      <tt>/lib/lsb/init-functions</tt>, which assists in writing
	      LSB-compliant init scripts, may fail if <tt>set -e</tt> is
	      in effect and echoing status messages to the console fails,
	      for example.
	    </footnote>.  For <tt>init.d</tt> scripts, it's often easier
	    to not use <tt>set -e</tt> and instead check the result of
	    each command separately.
	  </p>

	  <p>
	    The <file>/etc/init.d</file> scripts must be treated as
	    configuration files, either (if they are present in the
	    package, that is, in the .deb file) by marking them as
	    <tt>conffile</tt>s, or, (if they do not exist in the .deb)
	    by managing them correctly in the maintainer scripts (see
	    <url id="https://www.debian.org/doc/debian-policy/ch-files.html#s-config-files" name="Configuration files">).  This is important since we want
	    to give the local system administrator the chance to adapt
	    the scripts to the local system, e.g., to disable a
	    service without de-installing the package, or to specify
	    some special command line options when starting a service,
	    while making sure their changes aren't lost during the next
	    package upgrade.
	  </p>

	  <p>
	    These scripts should not fail obscurely when the
	    configuration files remain but the package has been
	    removed, as configuration files remain on the system after
	    the package has been removed.  Only when <prgn>dpkg</prgn>
	    is executed with the <tt>--purge</tt> option will
	    configuration files be removed.  In particular, as the
	    <file>/etc/init.d/<var>package</var></file> script itself is
	    usually a <tt>conffile</tt>, it will remain on the system
	    if the package is removed but not purged.  Therefore, you
	    should include a <tt>test</tt> statement at the top of the
	    script, like this:
	    <example compact="compact">
test -f <var>program-executed-later-in-script</var> || exit 0
	    </example>
	  </p>

	  <p>
            Files and directories under <file>/run</file>, including ones
            referred to via the compatibility paths <file>/var/run</file>
            and <file>/var/lock</file>, are normally stored on a temporary
            filesystem and are normally not persistent across a reboot.
            The <file>init.d</file> scripts must handle this correctly.
            This will typically mean creating any required subdirectories
            dynamically when the <file>init.d</file> script is run.
            See <url id="https://www.debian.org/doc/debian-policy/ch-opersys.html#s-fhs-run" name="Debian policy on /run"> for more information.
	  </p>

          <p>
            There used to be another directory, <file>/etc/rc.boot</file>,
            which contained scripts which were run once per machine
            boot. This has been deprecated in favour of links from
            <file>/etc/rcS.d</file> to files in <file>/etc/init.d</file> as
            described in <ref id="/etc/init.d">.  Packages must not
            place files in <file>/etc/rc.boot</file>.
	  </p>
	</sect1>
	<sect1>
	  <heading>Example</heading>

	  <p>
	    An example on which you can base your
	    <file>/etc/init.d</file> scripts is found in
	    <file>/etc/init.d/skeleton</file>.
	  </p>
	</sect1>
    </sect>

    <sect id="systemdunits">
      <heading>systemd unit files</heading>

      <sect1>
        <heading>pulled in from systemd best practices pad</heading>
        <p>
From https://etherpad.fr/p/systemd-best-practices

---

Best practices for systemd support in Debian packages

* Packages SHOULD use dh-systemd.
* Maintainer scripts MUST use deb-systemd-helper and deb-systemd-invoke.
* Maintainer SHOULD NOT rename .service files but use symlink instead to mask LSB scripts
* Units SHOULD be installed with --restart-after-upgrade.

    (As long as the package will not break, but most will work fine.)

* Units SHOULD NOT use Type=forking or PIDFile; instead, units should invoke daemons with options that tell them to remain in the foreground.
* Units capable of running with NoNewPrivileges=yes MUST use NoNewPrivileges=yes.

    (Unless setuid(2) or running suid programs is actually needed.)

    Beware: it breaks sending mail with Postfix.  (Perhaps postfix and other implementations of sendmail should connect to port 25 or a UNIX socket, rather than using setuid/setgid and directly dropping files into privileged locations? No, because the whole point of the maildrop directory is to allow queueing mail when the daemon is not running.)

    How does this interact with LSMs like AppArmor? The documentation states:

        "Be careful, though: LSMs might also not tighten constraints on exec
         in no_new_privs mode.  (This means that setting up a general-purpose
         service launcher to set no_new_privs before execing daemons may
         interfere with LSM-based sandboxing.)"

* Units SHOULD run with minimal privileges: let systemd invoke the daemon as a regular user, rather than invoking it as root and letting it drop privileges.
* Units that run with elevated privileges SHOULD use CapabilityBoundingSet.

    (Not mandatory because creating a policy may be hard.)

    (And encouraging using SystemCallFilter would be nice too.)

* Units MUST use Restart=on-failure or Restart=on-abnormal, as appropriate.

    FIXME: clarify how to choose this parameter.

* Units invoking services that do not require access to networks other than localhost SHOULD use PrivateNetwork. Note that some actions may unexpectedly require network access, such as resolving non-system users or groups via NSS.

    But this only matters for network daemons which listen on external interfaces, since local users already have access to the network interfaces.

    And does not work for anything which needs to resolve domains or users (think about LDAP/NIS).

    Only for non-system users; system users are already required to exist locally.

    Or use syslog. There are so many things that could break that I do not feel confident enough to even use a SHOULD.

    I've changed it to something less specific, and just recommend using it if possible.

* Units SHOULD use PrivateTmp (if the daemon uses tempfiles) and PrivateDevices.
* Units SHOULD use ProtectHome and ProtectSystem (full or on) (requires systemd >= 214)
* Packages MUST NOT ship units, tmpfiles configuration, or other systemd  configuration in /etc; they MUST ship it in the systemwide locations in  /lib instead.  Configuration of systemd components in /etc is reserved  exclusively for the system administrator, as it overrides corresponding  configuration in /usr.
* Units SHOULD use socket and/or bus activation wherever possible.  Socket/bus activation avoids the need to declare and maintain dependencies, instead allowing daemons and their dependencies to launch in parallel.  A package MAY allow the activated unit to launch on demand and exit when unused, or MAY launch it proactively at system startup, depending on user-desired behavior.
* Packages that previously shipped init.d scripts referencing settings from a file in /etc/default/\$defaultfile (such as to disable or configure the daemon) SHOULD do a one-time migration of appropriate settings from that file to corresponding override files in /etc/systemd.  Unit files MUST NOT reference files in /etc/default directly.

    To migrate a setting used to enable/disable a unit, create a symlink from /etc/systemd/system/\$unit to /dev/null.  However, if the daemon has a required configuration file, the preferred way to ship a disabled-by-default daemon is to ship that example file in /usr/share/doc/\$package, and use ConditionPathExists=/etc/... in the unit file to only launch the daemon if configured.

    To migrate a setting specifying command-line options or environment variables for a daemon, create a drop-in file /etc/systemd/system/\${package}.service.d/migrated-from-etc-default-\${package}.conf overriding the corresponding directives.  Only create this file if the settings in /etc/default do not match the package defaults, and only override the directives necessary to migrate the settings changed from the default.  Create this file even for services also disabled via a symlink to /dev/null.

    This may work for corner cases but it could be very complex to implement in a general way.

    It's unlikely that we can implement a fully general solution in a helper package; some packages will need custom code handling this migration.

* Programs SHOULD handle the dynamic addition and removal of network devices and addresses.  (Note that programs listening on all interfaces or on localhost only  will work by default, and programs configured to listen on a specific  address can use IP_FREEBIND rather than waiting for configuration of  that address.) Units for software that does not support dynamic addition and removal of network devices and addresses MUST depend on network-online.target, which blocks until after attempting to bring up all system-wide networks.

    I'd certainly love to make it a "MUST", but that would make too many packages instantly RC-buggy.  Let's start with SHOULD, and move to MUST when we've fixed some of the higher-profile broken cases.

    This is why my original formulation was conditional to support for dynamic interfaces: "Units MUST NOT depend on network-online.target unless the daemon is unable to handle the dynamic addition and removal of network devices".

    That's fine as long as there's a SHOULD for supporting the dynamic addition and removal of network devices.

    Then I propose: daemons SHOULD support dynamic addition and removal of network devices and IP addresses, but if and only if they do not then they MUST depend on network-online.target.

    Sounds good. Done.

* Units, or code invoked synchronously from units, MUST NOT invoke other services using systemctl, service, or similar tools; doing so may lead to deadlock.  Such invocations typically indicate the need for a dependency, instead.
* Units MUST either omit the StandardOutput and StandardError directives, or specify them as "null" if the invoked program produces excessive uninteresting output on standard output or standard error.  Units MUST NOT set any other value for StandardOutput or StandardError; doing so overrides the system administrator's preferred configuration from DefaultStandardOutput and DefaultStandardError in systemd-system.conf.
* Packages shipping a unit that specify a Conflicts= against unit files shipped as part of systemd MUST NOT break any software relying on the interface provided by that unit file.
* Socket units MUST be stopped at the right time while upgrading and removing the package. 

    FIXME: describe the right time.

    FIXME: can we make dh-systemd do it automatically?

* Provide "standard" unit files examples for a simple plain daemon and a socket-activated/bus-activated one.
* FIXME: provide correct snippet to test whether running under systemd, if absolutely necessary.

    When would this be necessary? Do we need to explicit the cases?

    Most frequently, this would be needed for code that should *not* run under systemd, but which sysvinit or similar systems need to work around issues.  For instance, the recent case of removing a telinit call to reload init.

    Then maybe that code should check if such a different init system is running?

* FIXME: Packages which ship both a unit file and an /etc/init.d/ service MUST depend on ... / recommend ...
* FIXME: Packages which ship only a systemd unit file, or otherwise depend on systemd, MUST depend on ...

    Packages SHOULD accept patches adding support for other init systems, if feasible and maintainable.(We have the CTTE decision for this, it is out of place in this document.) (Actually, Debian Policy is exactly the right place to provide the language implementing this decision.)

* FIXME: Packages using functionality of systemd only present in a given version V or newer MUST depend on ... (>= V)
  What about packages where the .service file uses functionality only available in version V of systemd, but also supports sysvinit, upstart?
  It should not Depend on systemd in this case and listing all sysvinit-compatible init systems isn't that great either...

      Virtual package for "init system supporting /etc/init.d", perhaps?

  They need a Breaks on older systemd versions. But this about is basic packaging so we do not really need to repeat it.
  Won't that lead to apt potentially replacing systemd with a different init system to solve the Breaks?

      It would indeed.  I think we want a dependency, not a conflicts/breaks.

* FIXME: We need a policy for using systemd-tmpfiles via tmpfiles.d.  Can we support use of that under other init systems?
* FIXME, in a separate section of Policy: Packages SHOULD NOT assume that /tmp can hold arbitrarily large files; some systems may mount /tmp as an in-memory filesystem such as tmpfs, and putting excessive data in /tmp may fail or consume excessive memory.  Packages SHOULD place potentially large temporary files in /var/tmp/ instead.  Packages SHOULD still prefer \$TMPDIR to /var/tmp if set.

    Let's postpone this debian-devel flamewar to another time, OK? If Red Hat is going to ship a tmpfs /tmp by default then other packages will adapt.

    Making it a SHOULD NOT rather than a MUST NOT dodges the flamewar. A "SHOULD NOT" justifies filing a normal bug, but not an RC bug, which seems quite reasonable.

    RHEL7 does NOT use a tmpfs by default, so let's just ignore this for a few more years.

* Packages must not override services from other packages, or install drop-ins modifying services from other packages, without coordination with those packages.

Next actions:
    What shall we do with this? Is a page on wiki.d.o enough? If this should become part of the Policy, is anybody available to shepherd it trought the process?
Useful resources:

    http://fedoraproject.org/wiki/Changes/PrivateDevicesAndPrivateNetwork
        </p>
      </sect1>

    </sect>
    <sect id="upstartjobs">
      <heading>upstart job files</heading>
	  <p>
            Packages may integrate with the <prgn>upstart</prgn> event-based
            boot system by installing job files in the
            <file>/etc/init</file> directory.
          </p>

          <p>
            SysV init scripts for which
            an equivalent upstart job is available must query the output of
            the command <prgn>initctl version</prgn> for the string
            <tt>upstart</tt> and avoid running in favor of the native
            upstart job, using a test such as this:
	    <example compact="compact">
if [ "$1" = start ] && which initctl >/dev/null && initctl version | grep -q upstart
then
	exit 1
fi
	    </example>
          </p>

          <p>
            Because packages shipping upstart jobs may be installed on
            systems that are not using upstart, maintainer scripts must
            still use the common <prgn>update-rc.d</prgn> and
            <prgn>invoke-rc.d</prgn> interfaces for configuring runlevels
            and for starting and stopping services.  These maintainer
            scripts must not call the upstart <prgn>start</prgn>,
            <prgn>restart</prgn>, <prgn>reload</prgn>, or <prgn>stop</prgn>
            interfaces directly.  Instead, implementations of
            <prgn>invoke-rc.d</prgn> must detect when upstart is running and
            when an upstart job with the same name as an init script is
            present, and perform the requested action using the upstart job
            instead of the init script.
          </p>
          <p>
            Dependency-based boot managers for SysV init scripts, such as
            <prgn>startpar</prgn>, may avoid running a given init script
            entirely when an equivalent upstart job is present, to avoid
            unnecessary forking of no-op init scripts.  In this case, the
            boot manager should integrate with upstart to detect when the
            upstart job in question is started or stopped to know when the
   
         dependency has been satisfied.
         </p>
    </sect>
  </chapt>

  <chapt id="initsysmaint">
    <heading>Maintaining an Init System</heading>
    <sect id="sbininit">
      <heading>Providing /sbin/init</heading>
    </sect>
    <sect id="boothooks">
      <heading>Hooking into the boot system</heading>
    </sect>
    <sect id="policyhooks">
      <heading>Hooking into the init policy system</heading>
      <p>(Covers update-rc.d, invoke-rc.d, policy-rc.d, /usr/sbin/service, etc)</p>
    <sect id="initpkgnames">
      <heading>Related packages</heading>
    </sect>
  </chapt>

  <chapt id="legacy">
     <heading>Legacy documentation imported from Debian Policy</heading>

      <sect id="sysvinit">
	<heading>System run levels and <file>init.d</file> scripts</heading>

	<sect1 id="/etc/init.d">
	  <heading>Introduction</heading>

          <p>
            These scripts are referenced by symbolic links in the
	    <file>/etc/rc<var>n</var>.d</file> directories.  When changing
	    runlevels, <prgn>init</prgn> looks in the directory
	    <file>/etc/rc<var>n</var>.d</file> for the scripts it should
	    execute, where <tt><var>n</var></tt> is the runlevel that
	    is being changed to, or <tt>S</tt> for the boot-up
	    scripts.
	  </p>

          <p>
	    The names of the links all have the form
	    <file>S<var>mm</var><var>script</var></file> or
	    <file>K<var>mm</var><var>script</var></file> where
	    <var>mm</var> is a two-digit number and <var>script</var>
	    is the name of the script (this should be the same as the
	    name of the actual script in <file>/etc/init.d</file>).
	  </p>

          <p>
	    When <prgn>init</prgn> changes runlevel first the targets
	    of the links whose names start with a <tt>K</tt> are
	    executed, each with the single argument <tt>stop</tt>,
	    followed by the scripts prefixed with an <tt>S</tt>, each
	    with the single argument <tt>start</tt>.  (The links are
	    those in the <file>/etc/rc<var>n</var>.d</file> directory
	    corresponding to the new runlevel.)  The <tt>K</tt> links
	    are responsible for killing services and the <tt>S</tt>
	    link for starting services upon entering the runlevel.
	  </p>

	  <p>
	    For example, if we are changing from runlevel 2 to
	    runlevel 3, init will first execute all of the <tt>K</tt>
	    prefixed scripts it finds in <file>/etc/rc3.d</file>, and then
	    all of the <tt>S</tt> prefixed scripts in that directory.
	    The links starting with <tt>K</tt> will cause the
	    referred-to file to be executed with an argument of
	    <tt>stop</tt>, and the <tt>S</tt> links with an argument
	    of <tt>start</tt>.
	  </p>

	  <p>
	    The two-digit number <var>mm</var> is used to determine
	    the order in which to run the scripts: low-numbered links
	    have their scripts run first.  For example, the
	    <tt>K20</tt> scripts will be executed before the
	    <tt>K30</tt> scripts.  This is used when a certain service
	    must be started before another.  For example, the name
	    server <prgn>bind</prgn> might need to be started before
	    the news server <prgn>inn</prgn> so that <prgn>inn</prgn>
	    can set up its access lists.  In this case, the script
	    that starts <prgn>bind</prgn> would have a lower number
	    than the script that starts <prgn>inn</prgn> so that it
	    runs first:
	    <example compact="compact">
/etc/rc2.d/S17bind
/etc/rc2.d/S70inn
	    </example>
	  </p>

	  <p>
	    The two runlevels 0 (halt) and 6 (reboot) are slightly
	    different.  In these runlevels, the links with an
	    <tt>S</tt> prefix are still called after those with a
	    <tt>K</tt> prefix, but they too are called with the single
	    argument <tt>stop</tt>.
	  </p>
	</sect1>

      </sect>


      <sect id="alternateinit">
        <heading>Alternate init systems</heading>
        <p>
          A number of other init systems are available now in Debian that
          can be used in place of <package>sysvinit</package>.  Alternative
          init implementations must support running SysV init scripts as
          described at <ref id="sysvinit"> for compatibility.
        </p>
        <p>
          Packages may integrate with these replacement init systems by
          providing implementation-specific configuration information about
          how and when to start a service or in what order to run certain
          tasks at boot time.  However, any package integrating with other
          init systems must also be backwards-compatible with
          <package>sysvinit</package> by providing a SysV-style init script
          with the same name as and equivalent functionality to any
          init-specific job, as this is the only start-up configuration
          method guaranteed to be supported by all init implementations.  An
          exception to this rule is scripts or jobs provided by the init
          implementation itself; such jobs may be required for an
          implementation-specific equivalent of the <file>/etc/rcS.d/</file>
          scripts and may not have a one-to-one correspondence with the init
          scripts.
        </p>
      </sect>

  </chapt>
</book>
