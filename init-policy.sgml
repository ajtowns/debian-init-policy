<!doctype debiandoc system [
<!entity % versiondata SYSTEM "version.ent"> %versiondata;
<!entity changesversion "1.8">
]>
<debiandoc>
<book>
  <titlepag>
    <title>Debian Init Policy Manual</title>
    <author>The Debian Policy Mailing List</author>
    <version>version &version;, &date;</version>

    <abstract>
      This manual describes the requirements for init systems
      and init scripts within the Debian distribution.
    </abstract>

    <copyright>See the Debian Policy manual</copyright>

  </titlepag>

  <toc detail="sect1">

  <chapt id="admin">
    <heading>Managing Daemons on a Debian System</heading>
    <sect id="startstop">
      <heading>Starting and stopping a daemon</heading>
      <p>
      The standard way to start and stop a daemon in Debian, independent of which
      init system in use is to use either the <prgn>service</prgn> or
      <prgn>invoke-rc.d</prgn> commands. For example:
      <list>
      <item><prgn>service ssh stop</prgn></item>
      <item><prgn>invoke-rc.d ssh start</prgn></item>
      </list>
      </p>
      <p>
      The difference between the two commands is that <prgn>service</prgn>
      is unconditional, while <prgn>invoke-rc.d</prgn> will only act
      if the service is currently enabled (ie, configured to start
      on boot, or in the current runlevel). <prgn>invoke-rc.d</prgn>
      is primarily useful for scripts, and is commonly called by the
      maintainer scripts when installing, upgrading or removing packages.
      </p>
      <p>
      Historically, it has been common to invoke the init scripts
      in <file>/etc/init.d</file> directly, using a command such as
      <prgn>/etc/init.d/ssh restart</prgn>. This remains supported
      (and in a systemd environment, such a command will actually invoke
      <prgn>systemctl</prgn> instead), but this is considered "legacy"
      behaviour, and admins are encouraged to transition to using
      the <prgn>service</prgn> command. A major disadvantage to invoking
      the init script script directly in this manner is that the admin's
      environment settings can be accidently inheritted by the daemon,
      and caused unwanted misbehaviour.
      </p>
      <p>
      When using systemd, <prgn>service</prgn> and
      <prgn>invoke-rc.d</prgn> will operate on both init.d
      scripts and systemd service files, but will not work
      with other types of unit files. In this case, admins are
      required to use <prgn>systemctl</prgn> directly (instead of
      <prgn>service</prgn>) or <prgn>deb-systemd-invoke</prgn> (instead
      of <prgn>invoke-rc.d</prgn>).
      </p>
    </sect>

    <sect id="enabledisable">
      <heading>Enabling and disabling a daemon</heading>
      <p>
      To set a service to run at boot-time, the command
      <prgn>update-rc.d</prgn> should be used:

      <list>
      <item><prgn>update-rc.d ssh enable</prgn></item>
      <item><prgn>update-rc.d ssh disable</prgn></item>
      </list>
      </p>

      <p>
      On Debian systems, all services default to being enabled immediately
      upon installation.
      </p>

      <p>
      When using systemd, <prgn>update-rc.d</prgn> will operate on
      init.d scripts and systemd service files, but will not work with other
      types of unit files. In this case, admins will need to use
      <prgn>systemctl</prgn> directly. A program <prgn>deb-systemd-helper</prgn>
      is also available for this task, however it is intended solely to be used by
      packages during installation and removal.
      </p>
    </sect>

    <sect id="policyrcd">
      <heading>Using policy-rc.d to set daemon policy on install/upgrade</heading>
      <p>
      System administrators may provide a
      <prgn>/usr/sbin/policy-rc.d</prgn> to alter the
      default behaviour of <prgn>invoke-rc.d</prgn>. Note that
      <prgn>update-rc.d</prgn> does not consult <prgn>policy-rc.d</prgn>.
      </p>

      <p>
      A handful of packages in the archive supply implementations of
      <prgn>policy-rc.d</prgn>.
      </p>

      <p>
      The <prgn>policy-rc.d</prgn> script is called using the following
      convention:

      <list>
      <item><prgn>policy-rc.d "<var>$SERVICE</var>" "<var>$ACTIONS</var>" <var>$RUNLEVELS</var></prgn></item>
      <item><prgn>policy-rc.d --list "<var>$SERVICE</var>" <var>$RUNLEVELS</var></prgn></item>
      </list>
      </p>

      <p>
      Error messages may be sent to <tt>stderr</tt>, unless <tt>--quiet</tt>
      is specified as the first argument.
      </p>

      <p>
      Supporting the <tt>--list</tt> argument is optional, as it is not
      used by <prgn>invoke-rc.d</prgn>. If supported, it should provide
      a human-readable list of the policies, actions and fallbacks for
      the given service, in the specified runlevels (or all runlevels
      if no runlevels are specified).
      </p>

      <p>
      When invoked ordinarily, <prgn>policy-rc.d</prgn> should do one
      of the following:

      <taglist>
      <tag>allow action</tag>
      <item>Exit with status code <tt>0</tt>.</item>

      <tag>forbid action</tag>
      <item>Exit with status code <tt>101</tt>.</item>

      <tag>override action</tag>
      <item>Exit with status code <tt>106</tt>, and output replacement
      actions on a single line, separated by spaces. Replacement actions
      will be attempted sequentially until one of them succeeds.</item>

      <tag>undefined policy</tag>
      <item>Exit with status code <tt>1</tt> or
      <tt>105</tt>. <prgn>invoke-rc.d</prgn> will emit an error message,
      but then act as if the action was allowed.</item>

      <tag>internal error</tag>
      <item>Exit with status code <tt>100</tt> (unknown service),
      <tt>102</tt> (subsystem error) or <tt>103</tt> (syntax
      error). <prgn>invoke-rc.d</prgn> will exit with the same status
      code.</item>

      </taglist>

      The most useful behaviours are allowing, forbidding and overriding
      actions.  </p> <p> Note that <var>$ACTIONS</var> may be a single
      action (<tt>start</tt>, <tt>stop</tt>, etc), or may be a space
      separated list of actions.
      </p>

      <p>
      If <prgn>invoke-rc.d</prgn> detects an out-of-runlevel start or
      restart attempt, the action will be replaced by <tt>(start)</tt>
      or <tt>(restart)</tt> as appropriate before <prgn>policy-rc.d</prgn>
      is called.
      </p>

      <p>
      The runlevel parameters are optional. If a runlevel is not
      specified, it is considered to be unknown/undefined. A runlevel for
      update-rc.d is defined as a character string, of which the usual
      INIT one-character runlevels are only a subset. It may contain
      embedded blanks.
      </p>
    </sect>

    <sect>
      <heading>Different Init Models</heading>

      <p>A variety of models for loading and monitoring daemons and services
      have been created, and are supported on Debian systems.
      </p>

      <sect1>
      <heading>systemd</heading>
      <p>systemd is the default init system as of Debian 8 (jessie). It
      has a variety of methods of activating daemons/services, including
      socket-based activation (started when a socket is accessed),
      bus-based activation (started when a client attempts to communicate
      with it over D-Bus), device-based activation (started when certain
      hardware is plugged in or otherwise becomes available), and others.
      </p>

      <p>systemd uses "unit" files to determine how to manage
      services and the system as a whole. Units can be provided by
      packages (via <file>/lib/systemd/system/</file>), the admin (via
      <file>/etc/systemd/system/</file>), or programmatically by systemd
      "generators" (via <file>/run/systemd/system/</file>).
      </p>

      <p>systemd determines what services to start via a "target" unit. A
      target unit is a way of collecting a group of units together
      via dependencies. The default target is <tt>graphical.target</tt> which
      in turn requires <tt>multi-user.target</tt>.</p>

      <p>systemd provides a <prgn>systemctl</prgn> command for controlling
      services at runtime.<p>

      <p>Installing the <tt>systemd-sysv</tt> package will set systemd as
      the default method for booting the system and starting services.
      </p>
      </sect1>

      <sect1>
      <heading>SysV Init</heading>
      <p>The traditional method of starting a Debian system was
      System V style init. This involves running a series of scripts from
      <file>/etc/init.d</file> to start and stop services.
      </p>

      <p>SysV uses the concept of "runlevels" to allow a system to be
      in different states, corresponding to a different combination
      of running services. In Debian, runlevels 2, 3, 4 and 5 are by
      default treated as equivalent, and the default runlevel is 2.
      </p>

      <p>Scripts are associated with a runlevel by placing symlinks in
      the <file>/etc/rcN.d/</file> corresponding with the runlevel, and
      prefixed with <tt>S<var>NN</var></tt> or <tt>K<var>NN</var></tt>
      denoting whether the service should be started (S) or killed
      (K) when entering this runlevel, and the order in which the
      services should be started or stopped (<tt><var>NN</var></tt>
      from <tt>00</tt> to <tt>99</tt>). This ordering is set by the
      <tt>insserv</tt> program based on LSB-style dependency headers
      within the init scripts themselves.
      </p>

      <p>Installing the <tt>sysvinit-core</tt> package will set SysV-style
      init as the default method for booting the system and starting
      services.
      </p>

      <p>Installing <tt>file-rc</tt> will change the SysV-init system from
      using symlinks to associate scripts with runlevels, to using a single
      text-based configuration file instead.</p>
      </sect1>
  </chapt>

  <chapt id="daemonmaint">
    <heading>Maintaining a Daemon</heading>

    <sect id="background">
      <heading>Background</heading>
          <p>
            There are a variety of different ways of launching daemons
            at boot time. The traditional approach, known as
            SysV-style init, uses executable scripts located in
            <file>/etc/init.d</file>, however newer solutions such as
            <prgn>systemd</prgn> and <prgn>upstart</prgn> use a more
            descriptive approach to manage daemons.
          </p>
          <p>
            In Debian, the default init system for Linux architectures
            is <prgn>systemd</prgn>, and as a consequence, packages
            providing daemons should work under systemd. This can be
            achieved either by providing a native systemd unit file,
            or by providing an LSB-style init.d script making use of
            systemd's sysv compatability.
          </p>
          <p>
            Providing a unit file is often a more powerful approach,
            offering more fine-grained management of the service, so
            in general this is recommended. Ideally, a unit file will
            be common across distributions, and can thus be maintained
            upstream. On the other hand, providing an init script is
            necessary in order for the daemon to work with alternative
            init systems and non-Linux kernels (where systemd is not
            available), so if upstream does not provide an acceptable
            unit file, it may be easier to just maintain an init script,
            rather than an init script and a unit file.
          </p>
    </sect>

    <sect id="systemdunits">
      <heading>Unit Files</heading>

      <p>
        Unit files are documented via the systemd man pages, see
        <manref name="systemd.unit" section="5">,
        <manref name="systemd.service" section="5">,
        <manref name="systemd.socket" section="5">,
        <manref name="systemd.directives" section="5">,
        and related pages.
     </p>

     <p>
        Example unit files are available at <url id="https://wiki.debian.org/systemd/Packaging">.
     </p>

     <sect1>
         <heading>General advice</heading>

         <p>Most of the techniques for writing good unit files are
         generally applicable, rather than specific to Debian. As
         such, using the upstream systemd documentation directly is
         generally advisable, and it also makes sense to work closely
         with upstream and other distributions<footnote>Fedora's
         packaging guidelines for systemd units can be found at <url
         id="http://fedoraproject.org/wiki/Packaging:Systemd"></footnote>
         when working on unit files. However, a few items are worth
         calling out here:

         <list>
         <item>
           <p>Where possible, units should not use <tt>Type=forking</tt>
           or <tt>PIDFile</tt>, but instead should invoke daemons with
           options that tell them to remain in the foreground. This
           allows systemd to provide better monitoring of the process.

           <p>If the daemon supports the native systemd readiness protocol,
           that should usually be used (by setting <tt>Type=notify</tt>).
         </item>

         <item>
           <p>If the daemon has options to output useful logging information
           on standard output and/or standard error, these should be enabled.

           <p>As a consequence, units should usually omit the <tt>StandardOutput</tt>
           and <tt>StandardError</tt> directives, but may specify
           them as <tt>"null"</tt> if the invoked program produces
           excessive uninteresting output on standard output or
           standard error. Units should not set any other value for
           StandardOutput or StandardError; doing so would override
           the system administrator's preferred configuration
           from DefaultStandardOutput and DefaultStandardError in
           systemd-system.conf.
         </item>

         <item>
           Units should use socket and/or bus activation wherever
           possible. Socket and bus activation avoids the need to declare and
           maintain dependencies on the service, instead allowing daemons
           and their dependencies to launch in parallel. A package may
           allow the activated unit to launch on demand and exit when
           unused, or may launch it proactively at system startup,
           depending on user-desired behavior.
         </item>

         <item>
           Units should use the <tt>Restart=</tt> directive to allow
           services to be automatically restarted if they crash. Using
           <tt>Restart=on-failure</tt> is the recommended way to do this,
           which will cause systemd to restart the service in the vast
           majority of error scenarios, but will not restart the service
           if it exits with an exit code of zero. Other options that may
           be worth considering are <tt>Restart=on-abnormal</tt> and
           <tt>Restart=always</tt>. Note that <tt>Restart=always</tt>
           will not allow socket-activated services to automatically
           stop when idle. (The way restarts are throttled can be
           configured configured by the <tt>StartLimitInterval</tt>
           and <tt>StartLimitBurst</tt> options)
         </item>

         <item>
           Avoid using <tt>Accept=yes</tt> in .socket files,
           because <manref name="service" section="8"> will
           not be able to stop that service correctly. For
           example, if you have <file>approx.socket</file> and
           <file>approx@.service</file>, which gets expanded to
           <file>approx@1-::1:9999-::1:44903.service</file>, then
           <prgn>service approx stop</prgn> will not work.
         </item>

         <item>
           <p>If a daemon needs to wait until all network interfaces are
           configured, this can be achieved by specifying a dependency
           on <tt>network-online.target</tt> will block the service until
           after attempting to bring up all system-wide networks.</p>

           <p>However, daemons should handle the dynamic addition
           and removal of network devices and addresses, rather
           than expecting to only be started after all interfaces
           are configured. Programs listening on all interfaces,
           or only on localhost will work this way by default. For
           programs configured to listen on a specific address, using
           the IP_FREEBIND option from <manref name="ip" section="7">
           with <manref name="setsockopt" section="2"> will achieve
           this behaviour.</p>
         </item>

         </list>

         <p>Services should always run with minimal privileges to reduce
         the potential attack surface, in the event that an attacker
         finds exploitable bugs in the service. This can be done in a
         number of ways:

         <list>
         <item>Let systemd invoke the daemon as a regular user directly
         using the <tt>User</tt> directive, rather than invoking it
         as root and letting it drop privileges.</item>

         <item>If possible, set <tt>NoNewPrivileges=yes</tt>. This will
         prevent the daemon from elevating its privileges by invoking
         setuid binaries that may be installed.</item>

         <item>Units should usually set <tt>PrivateTmp=yes</tt>,
         and <tt>PrivateDevices=yes</tt>.</item>

         <item>Units should usually set <tt>ProtectSystem=full</tt>,
         to prevent changes being made under <file>/usr</file> or
         <file>/etc</file>. <tt>ProtectHome</tt> should usually be set
         to <tt>yes</tt> or <tt>readonly</tt> depending on the nature
         of the service.</item>

         <item>Some units may be able to use other security features
         provided by systemd, such as <tt>PrivateNetwork</tt>,
         <tt>SELinuxContext</tt>, <tt>AppArmorProfile</tt>,
         <tt>CapabilityBoundingSet</tt>, <tt>SystemCallFilter</tt>,
         or <tt>RestrictAddressFamilies</tt>.</item>
         </list>
     </sect1>

     <sect1>
         <heading>Packaging considerations</heading>

         <p>Packages must ship units, tmpfiles configuration, or
         other systemd configuration in <file>/lib/systemd</file>
         (rather than <file>/etc/systemd</file> or
         <file>/run/systemd</file>). Configuration of systemd components
         in /etc is managed by the system administrator, with defaults
         set via maintainer scripts as described later.

         <p>Units, including code invoked synchronously from units,
         must not invoke other services using <prgn>systemctl</prgn>,
         <prgn>service</prgn>, or similar tools; doing so may lead to
         deadlock.  Such invocations typically indicate the need for a
         dependency, instead.

         <p>Packages must not override services from other packages,
         or install drop-ins modifying services from other packages,
         without coordination with those packages. In particular, packages
         must not break any software relying on the interface provided by
         any unit file shipped as part of systemd, even when specifying
         a <tt>Conflicts=</tt> with the systemd-provided unit.</p>

         <p>Maintainers should be very cautious when considering
         introducing a dependency on systemd (which will usually be a
         dependency on <tt>systemd-sysv</tt>), as apt and dpkg will
         happily switch a system's init to systemd with little warning
         if they encounter such a dependency. An obvious resolution is
         to make the package work with alternative init systems, however
         if the daemon can reasonably be run by hand (rather than started
         automatically by init), that may also be sufficient reason to
         pass up on the dependency.

         <p>If a package uses features only present in a recent version
         of systemd, that should usually be specified by a versioned
         Breaks relationship, eg:

         <example>Breaks: systemd (&lt; 215)</example>

         If this is done, the package must not be
         uploaded to unstable until the needed version of systemd is
         already in testing; otherwise the package runs the risk of being
         promoted to testing before the needed version of systemd, and apt
         may resolve the dependency by unexpectedly replacing systemd with
         an alternative init system, rather than holding the package back.
         (If such a package is uploaded to unstable, it is appropriate to
         file a release-critical bug to hold it back from testing until systemd
         is promoted to testing)
      </sect1>

      <sect1>
        <heading>Init Scripts</heading>

        <p>The following advice applies to packages that ship a unit
        file and an init script for the same service.

        <p>When you are installing a systemd service file
        alongside of your SysV init script, you should name it
        correspondingly. For example the corresponding service
        file for <file>/etc/init.d/apache2</file> should be named
        <file>/lib/systemd/system/apache2.service</file>. This way,
        systemd will automatically prefer the native service file over the
        SysV init script and use that to start the service. 

        <p>If the names
        do not match, say your service file is provided by upstream and
        named <file>NetworkManager.service</file> and your existing SysV
        init script is called <file>/etc/init.d/network-manager</file>,
        you should simply use the <tt>Alias=</tt> directive, which tells
        systemctl to create a symlink. Augment the service file like this:

        <example>
        [Install]
        Alias=network-manager.service
        </example>

        <p>The init script must source
        <file>/lib/lsb/init-functions</file> so that running the init
        script manually gets redirected to a <prgn>systemctl</prgn>
        invocation and systemd can properly manage the service.
      </sect1>

      <sect1>
        <heading>Maintainer Scripts</heading>
        <p>
        <list>
        <item>
            Maintainer scripts should use <prgn>update-rc.d</prgn>
            or <prgn>deb-systemd-helper</prgn> to enable unit files to
            start on boot. Note that <prgn>update-rc.d</prgn> will only
            enable <tt>.service</tt> unit files.
        </item>
        <item>
            Maintainer scripts should use <prgn>deb-systemd-invoke</prgn>
            to restart units on upgrade.
        </item>
        <item>
            Where the service needs to be stopped during preinst, packages
            should use <prgn>deb-systemd-helper</prgn> to mask the
            service file to prevent the service from being restarted while
            the package is being upgraded. This is particularly important
            for socket and D-Bus services that might be restarted implicitly
            by other processes or users.
        </item>
        </list>

        <p>Maintainers will usually want to use dh-systemd rather than
        ensuring their maintainer scripts do the right thing manually. To
        do this, add Build-Depends on <tt>dh-systemd (>= 1.5)</tt>, and
        change your <file>debian/rules</file> to invoke either <prgn>dh
        --with systemd</prgn> or <prgn>dh_systemd_enable</prgn>
        and <prgn>dh_systemd_start</prgn>.  Where possible,
        <prgn>dh_systemd_start</prgn>'s <tt>--restart-after-upgrade</tt>
        option should be used, so that the service remains active between
        dpkg's unpack and configure steps.
      </sect1>
    </sect>

    <sect id="init.d">
      <heading>init.d scripts</heading>
          <p>
            The <file>/etc/init.d</file> directory contains the scripts
            executed by <prgn>init</prgn> at boot time and when the
            init state (or "runlevel") is changed (see <manref
            name="init" section="8">).
          </p>

          <p>
            Packages that include daemons for system services should
            place scripts in <file>/etc/init.d</file> to start or stop
            services at boot time or during a change of runlevel.
            These scripts should be named
            <file>/etc/init.d/<var>package</var></file>.
          </p>

        <sect1>
          <heading>Arguments for init.d scripts</heading>
          <p>Scripts in init.d should
            accept one argument, saying what to do:

            <taglist>
              <tag><tt>start</tt></tag>
              <item>start the service</item>

              <tag><tt>stop</tt></tag>
              <item>stop the service</item>

              <tag><tt>restart</tt></tag>
              <item>stop and restart the service if it's already running,
                  otherwise start the service</item>

              <tag><tt>reload</tt></tag>
              <item><p>cause the configuration of the service to be
                  reloaded without actually stopping and restarting
                  the service</item>

              <tag><tt>force-reload</tt></tag>
              <item>cause the configuration to be reloaded if the
                  service supports this, otherwise restart the
                  service</item>

              <tag><tt>status</tt></tag>

              <item>report whether the service is running<footnote>A
                  service is running if the result of the <tt>start</tt>
                  action is in effect.</footnote>, exiting with status 0
                  if if the service is running, or, if the service is not
                  running, with a status other than 0<footnote>Packages
                  are encouraged to use the specific non-zero exit
                  statuses defined by LSB, but policy currently does
                  not require their use.  It is only required to
                  distinguish between 0 for running and not 0 for not
                  running.</footnote>. Scripts may wish to use the <tt>status_of_proc</tt>
                  function from <tt>/lib/lsb/init-functions</tt> to implement this
                  function, eg:
                  <example>status_of_proc /usr/sbin/sshd sshd && exit 0 || echo $?</example>
               </item>
            </taglist>

            The <tt>start</tt>, <tt>stop</tt>, <tt>restart</tt>,
            <tt>force-reload</tt>, and <tt>status</tt> options should be
            supported by all scripts in <file>/etc/init.d</file>; the
            <tt>reload</tt> option is optional.
          </p>

          <p>
            The <file>init.d</file> scripts must ensure that they will
            behave sensibly (i.e., returning success and not starting
            multiple copies of a service) if invoked with <tt>start</tt>
            when the service is already running, or with <tt>stop</tt>
            when it isn't, and that they don't kill unfortunately-named
            user processes.  The best way to achieve this is usually to
            use <prgn>start-stop-daemon</prgn> with the <tt>--oknodo</tt>
            option.
          </p>

          <p>
            If a service reloads its configuration automatically (as
            in the case of <prgn>cron</prgn>, for example), the
            <tt>reload</tt> option of the <file>init.d</file> script
            should behave as if the configuration has been reloaded
            successfully.
          </p>

          <p>
            Init scripts may wish to use the LSB exit status codes<footnote><url id="http://refspecs.linuxfoundation.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html"></footnote>. These are:

            <taglist>
            <tag>0</tag> <item>program is running or service is OK</item>
            <tag>1</tag> <item>program is dead and /var/run pid file exists</item>
            <tag>2</tag> <item>program is dead and /var/lock lock file exists</item>
            <tag>3</tag> <item>program is not running</item>
            <tag>4</tag> <item>program or service status is unknown</item>
            </taglist>
          </p>
          <p>
            Note however that when the service is
            removed but not purged the init script should exit with an error status
            of 0 on <tt>start</tt> or <tt>stop</tt>.
          </p>
          <p>
            Error codes 100-149 are reserved for distribution use,
            so may be used by packages if needed, however maintainers
            should discuss the introduction of such codes first, eg
            on the <tt>debian-devel</tt> or <tt>debian-policy</tt>
            lists. All other codes are reserved, and should not be used
            by Debian packages.
          </p>
         </sect1>

         <sect1>
           <heading>Environment and customisations</heading>

          <p>
            Often there are some variables in the <file>init.d</file>
            scripts whose values control the behavior of the scripts,
            and which a system administrator is likely to want to
            change.  As the scripts themselves are frequently
            <tt>conffile</tt>s, modifying them requires that the
            administrator merge in their changes each time the package
            is upgraded and the <tt>conffile</tt> changes.  To ease
            the burden on the system administrator, such configurable
            values should not be placed directly in the script.
            Instead, they should be placed in a file in
            <file>/etc/default</file>, which typically will have the same
            base name as the <file>init.d</file> script.  This extra file
            should be sourced by the script when the script runs.  It
            must contain only variable settings and comments in SUSv3
            <prgn>sh</prgn> format.  It may either be a
            <tt>conffile</tt> or a configuration file maintained by
            the package maintainer scripts.  See <url id="https://www.debian.org/doc/debian-policy/ch-files.html#s-config-files" name="Configuration files">
            for more details.
          </p>

          <p>
            To ensure that vital configurable values are always
            available, the <file>init.d</file> script should set default
            values for each of the shell variables it uses, either
            before sourcing the <file>/etc/default/</file> file or
            afterwards using something like the <tt>:
            ${VAR:=default}</tt> syntax.  Also, the <file>init.d</file>
            script must behave sensibly and not fail if the
            <file>/etc/default</file> file is deleted.
          </p>
         </sect1>

         <sect1>
          <heading>Dependencies between services</heading>
          <p>
          Often services will need to be started in a particular order;
          for example a remote file system may only be able to be mounted
          after networking is configured, and configuring networking
          may require a VPN service to be started. These dependencies are
          controlled using LSB-style headers<footnote><url id="http://refspecs.linuxfoundation.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/initscrcomconv.html"></footnote>
          in the init scripts themselves.
          </p>

          <p>
          One thing init scripts must not do is invoke other init scripts
          directly.  This interacts badly with dependency resolution
          using some init systems, and may cause services not to start or stop
          correctly.
          </p>

          <p>
          LSB init script headers are specified by a block in the init script
          beginning with <tt>### BEGIN INIT INFO</tt> and ending with
          <tt>### END INIT INFO</tt>.  Lines within the block are of the
          form <tt># <var>Keyword</var>: <var>arguments...</var></tt>,
          with exactly one space between the <tt>#</tt> and the keyword.
          </p>

          <p>Dependency related keywords include:
          <taglist>
          <tag>Provides: <var>service_1</var> <var>service_2...</var></tag>
          <item>Lists services provided by this script. Should usually include
          the script name.</item>

          <tag>Required-Start: <var>service_1</var> <var>service_2...</var></tag>
          <item>Lists services which need to be started before this
          service can be started.</item>

          <tag>Required-Stop: <var>service_1</var> <var>service_2...</var></tag>
          <item>Lists services which need to be available for this service
          to be stopped. This will often be the same set of services as
          in Required-Start.</item>

          <tag>Should-Start: <var>service_1</var> <var>service_2...</var></tag>
          <item>Lists services which, if present, should be started before
          this service is started. (If these services are not present, the
          service being started may have reduced functionality, eg)</item>

          <tag>Should-Stop: <var>service_1</var> <var>service_2...</var></tag>
          <item>As per Required-Stop/Should-Start.</item>

          <tag>X-Start-Before: <var>service_1</var> <var>service_2...</var></tag>
          <item>Lists services which, if present, should only be started after this
          service is started. This acts as if <tt>Should-Start: <var>me</var></tt>
          had been included in each of <var>service_1</var>, <var>service_2</var>'s
          init scripts.</item>

          <tag>X-Start-After: <var>service_1</var> <var>service_2...</var></tag>
          <item>As per Should-Stop/X-Start-Before.</item>

          <tag>Default-Start: <var>runlevels...</var></tag>
          <item>Lists runlevels the service should be activated in by
          default. For most Debian packages, this should be <tt>2 3
          4 5</tt>.</item>

          <tag>Default-Stop: <var>runlevels...</var></tag>
          <item>Lists runlevels the service should be deactivated in by
          default. For most Debian packages, this should be <tt>0 1
          6</tt>.</item>

          <tag>X-Interactive: true</tag>
          <item>Indicates that this init script can interact with the
          user, requesting some input (for example, a password). Note that
          this is a Debian extension and is not supported by systemd;
          if it is used a separate <tt>.service</tt> file for systemd
          must be included.</item>

          <tag>Short-Description: <var>short_description</var></tag>
          <item>Provides a brief description of the actions of the service.
          Limited to a single line of text.</item>

          <tag>Description: <var>multiline_description</var></tag>
          <item>Provides a more complete description of the actions
          of the init script. This is the only entry that may span
          multiple lines. In a multiline description, each continuation
          line begins with a '#' followed by tab character or a '#'
          followed by at least two space characters. The multiline
          description is terminated by the first line that does not
          match this criteria.</item>
          </taglist>
          </p>

          <p>
          There are some "virtual" service names that are used:

          <taglist>
          <tag>$local_fs</tag>
          <item>all local filesystems are mounted. All scripts that
          write in /var/ need to depend on this, unless they already
          depend on $remote_fs.</item>

          <tag>$network</tag>
          <item>low level networking (ethernet card; may imply PCMCIA running)</item>

          <tag>$named</tag>
          <item>daemons which may provide hostname resolution (if
          present) are running. For example, daemons to query DNS, NIS+,
          or LDAP.</item>

          <tag>$portmap</tag>
          <item>daemons providing SunRPC/ONCRPC portmapping service as
          defined in RFC 1833 (if present) are running</item>

          <tag>$remote_fs</tag>
          <item>all filesystems are mounted. In some LSB run-time
          environments, filesystems such as /usr may be remote. If
          the script need a mounted /usr/, it needs to depend on
          $remote_fs. Scripts depending on $remote_fs do not need to
          depend on $local_fs. During shutdown, scripts that need to
          run before sendsigs kills all processes should depend on
          $remote_fs.</item>

          <tag>$syslog</tag>
          <item>system logger is operational</item>

          <tag>$time</tag>
          <item>the system time has been set, for example by using
          a network-based time program such as ntp or rdate, or via
          the hardware Real Time Clock. Note that just depending
          on ntp will not result in an accurate time just after ntp
          started. It usually takes minutes until ntp actually adjusts
          the time. Also note that standard insserv.conf just lists
          hwclock as $time.</item>

          <tag>$all</tag>
          <item>facility supported by insserv to start a script after
          all the scripts not depending on $all, at the end of the
          boot sequence. This only work for start ordering, not stop
          ordering. Depending on a script depending on $all will give
          incorrect ordering, as the script depending on $all will be
          started after the script depending on it.</item>
          </taglist>
          </p>
         </sect1>


         <sect1>
          <heading>Invocation and registration</heading>
          <p>
            Maintainers should use the abstraction layer provided by
            the <prgn>update-rc.d</prgn> and <prgn>invoke-rc.d</prgn>
            programs to deal with initscripts in their packages'
            scripts such as <prgn>postinst</prgn>, <prgn>prerm</prgn>
            and <prgn>postrm</prgn>.
          </p>

          <p>
            Directly managing the /etc/rc?.d links and directly
            invoking the <file>/etc/init.d/</file> initscripts must only
            be done by packages providing the initscript
            subsystem (such as <prgn>sysv-rc</prgn> and
            <prgn>file-rc</prgn>).
          </p>

          <sect2>
            <heading>Managing the links</heading>

            <p>
              The program <prgn>update-rc.d</prgn> is provided for
              package maintainers to arrange for the proper creation and
              removal of <file>/etc/rc<var>n</var>.d</file> symbolic links,
              or their functional equivalent if another method is being
              used.  This may be used by maintainers in their packages'
              <prgn>postinst</prgn> and <prgn>postrm</prgn> scripts.
            </p>

            <p>
              You must not include any <file>/etc/rc<var>n</var>.d</file>
              symbolic links in the actual archive or manually create or
              remove the symbolic links in maintainer scripts; you must
              use the <prgn>update-rc.d</prgn> program instead.  (The
              former will fail if an alternative method of maintaining
              runlevel information is being used.)  You must not include
              the <file>/etc/rc<var>n</var>.d</file> directories themselves
              in the archive either.  (Only the <tt>sysvinit</tt>
              package may do so.)
            </p>

            <p>
              By default <prgn>update-rc.d</prgn> will start services in
              each of the multi-user state runlevels (2, 3, 4, and 5)
              and stop them in the halt runlevel (0), the single-user
              runlevel (1) and the reboot runlevel (6).  The system
              administrator will have the opportunity to customize
              runlevels by simply adding, moving, or removing the
              symbolic links in <file>/etc/rc<var>n</var>.d</file> if
              symbolic links are being used, or by modifying
              <file>/etc/runlevel.conf</file> if the <tt>file-rc</tt> method
              is being used.
            </p>

            <p>
              To get the default behavior for your package, put in your
              <prgn>postinst</prgn> script
              <example compact="compact">
                update-rc.d <var>package</var> defaults
              </example>
              and in your <prgn>postrm</prgn>
              <example compact="compact">
                if [ "$1" = purge ]; then
                    update-rc.d <var>package</var> remove
                fi
              </example>. Note that if your package changes runlevels
              or priority, you may have to remove and recreate the links,
              since otherwise the old links may persist. Refer to the
              documentation of <prgn>update-rc.d</prgn>.
            </p>

            <p>
              This will use a default sequence number of 20.  If it does
              not matter when or in which order the <file>init.d</file>
              script is run, use this default.  If it does, then you
              should talk to the maintainer of the <prgn>sysvinit</prgn>
              package or post to <tt>debian-devel</tt>, and they will
              help you choose a number.
            </p>

            <p>
              For more information about using <tt>update-rc.d</tt>,
              please consult its man page <manref name="update-rc.d"
                section="8">.
            </p>
          </sect2>

          <sect2>
            <heading>Running initscripts</heading>
            <p>
              The program <prgn>invoke-rc.d</prgn> is provided to make
              it easier for package maintainers to properly invoke an
              initscript, obeying runlevel and other locally-defined
              constraints that might limit a package's right to start,
              stop and otherwise manage services. This program may be
              used by maintainers in their packages' scripts.
            </p>

            <p>
              The package maintainer scripts must use
              <prgn>invoke-rc.d</prgn> to invoke the
              <file>/etc/init.d/*</file> initscripts, instead of
              calling them directly or using the <prgn>service</prgn>
              command or similar.
            </p>

            <p>
              By default, <prgn>invoke-rc.d</prgn> will pass any
              action requests (start, stop, reload, restart...) to the
              <file>/etc/init.d</file> script, filtering out requests
              to start or restart a service out of its intended
              runlevels.
            </p>

            <p>
              Most packages will simply need to change:
              <example compact="compact">/etc/init.d/&lt;package&gt; &lt;action&gt;</example>
              in their <prgn>postinst</prgn> and <prgn>prerm</prgn> scripts to:
              <example compact="compact">
                invoke-rc.d <var>package</var> &lt;action&gt;
              </example>
            </p>

            <p>
              A package should register its initscript services using
              <prgn>update-rc.d</prgn> before it tries to invoke them
              using <prgn>invoke-rc.d</prgn>. Invocation of
              unregistered services may fail.
            </p>

            <p>
              For more information about using
              <prgn>invoke-rc.d</prgn>, please consult its man page
              <manref name="invoke-rc.d" section="8">.
            </p>
          </sect2>
        </sect1>

        <sect1>
        <heading>Messages from <file>init.d</file> scripts</heading>

        <p>
          Init scripts should provide output indicating what
          actions are being taken, and whether they succeed or
          fail. To ensure a flexible and consistent approach to such
          messages, init scripts should use the log functions from
          <prgn>/lib/lsb/init-functions</prgn>.
        </p>

        <p>
          In order to use those functions, the package should specify a
          dependency on <tt>lsb-base</tt>, and source the init-functions
          script at the beginning of the init script, eg:
          <example>. /lib/lsb/init-functions</example>
        </p>

        <p>
          Here is a list of overall rules that should be used for
          messages generated by <file>/etc/init.d</file> scripts.
        </p>

        <p>
          <list>
            <item>
                The message should fit in one line (fewer than 80
                characters), start with a capital letter and end with
                a period (<tt>.</tt>).
            </item>

            <item>
                The messages should appear as if the computer is telling
                the user what it is doing (politely :-), but should not
                mention "it" directly.  For example, instead of:
                <example compact="compact">
I'm starting network daemons: nfsd mountd.
                </example>
                the message should say
                <example compact="compact">
Starting network daemons: nfsd mountd.
                </example>
            </item>

            <item>
              If the script is performing some time consuming task in
              the background (not merely starting or stopping a
              program, for instance), an ellipsis (three dots:
              <tt>...</tt>) should be output to the screen, with no
              leading or tailing whitespace or line feeds.
            </item>
          </list>
        </p>

        <p>
          <tt>init.d</tt> script should use the following  standard
          message formats for the situations enumerated below.

          <list>
            <item>
              <p>When daemons are started</p>

              <p>
                If the script starts one or more daemons, the output
                should look like this (a single line, no leading
                spaces):
                <example compact="compact">
Starting <var>description</var>: <var>daemon-1</var> ... <var>daemon-n</var>.
                </example>
                The <var>description</var> should describe the
                subsystem the daemon or set of daemons are part of,
                while <var>daemon-1</var> up to <var>daemon-n</var>
                denote each daemon's name (typically the file name of
                the program).
              </p>

              <p>
                For example, the output of <file>/etc/init.d/lpd</file>
                would look like:
                <example compact="compact">
Starting printer spooler: lpd.
                </example>
              </p>

              <p>
                This can be achieved by saying
                <example compact="compact">
log_daemon_msg "Starting printer spooler" "lpd"
start-stop-daemon --start --quiet --exec /usr/sbin/lpd
log_end_msg
                </example>
                in the script. If there is more than one daemon to
                start, the script should look like this:
                <example compact="compact">
log_daemon_msg "Starting remote file system services"
log_progress_msg "nfsd"; start-stop-daemon --start --quiet nfsd
log_progress_msg "mountd"; start-stop-daemon --start --quiet mountd
log_progress_msg "ugidd"; start-stop-daemon --start --quiet ugidd
log_end_msg
                </example>
                This makes it possible for the user to see what is
                happening and when the final daemon has been started.
                (Note that it will often be better to have separate init
                scripts for each daemon, linked together by specifying appropriate
                dependencies)
              </p>
            </item>

            <item>
              <p>When a daemon is stopped or restarted</p>

              <p>
                When you stop or restart a daemon, you should issue a
                message identical to the startup message, except that
                <tt>Starting</tt> is replaced with <tt>Stopping</tt>
                or <tt>Restarting</tt> respectively.
              </p>

              <p>
                For example, stopping the printer daemon will look like
                this:
                <example compact="compact">
Stopping printer spooler: lpd.
                </example>
              </p>
            </item>

            <item>
              <p>When a system parameter is being set</p>

              <p>
                If you have to set up different system parameters
                during the system boot, you should use this format:
                <example compact="compact">
Setting <var>parameter</var> to "<var>value</var>".
                </example>
              </p>

              <p>
                You can use a statement such as the following to get
                the quotes right:
                <example compact="compact">
log_action_msg "Setting DNS domainname to \"$domainname\"."
                </example>
              </p>

              <p>
                Note that the same symbol (<tt>"</tt>) <!-- " --> is used
                for the left and right quotation marks.  A grave accent
                (<tt>`</tt>) is not a quote character; neither is an
                apostrophe (<tt>'</tt>).
              </p>

              <p>
                This type of message can be used for any atomic action, that is
                not expected to take any time at all, and cannot fail.
              </p>
            </item>

            <item>
              <p>When something is executed</p>

              <p>
                There are several examples where you have to run a
                program at system startup or shutdown to perform a
                specific task, for example, setting the system's clock
                using <prgn>netdate</prgn> or killing all processes
                when the system shuts down.  Your message should look
                like this:
                <example compact="compact">
Doing something very useful...done.
                </example>
                You should print the <tt>done.</tt> immediately after
                the job has been completed, so that the user is
                informed why they have to wait.  You can get this
                behavior by saying
                <example compact="compact">
log_action_begin_msg "Doing something very useful"
do_something
log_action_end_msg $?
                </example>
                in your script.
              </p>

              <p>
                The first argument to <tt>log_action_end_msg</tt> is
                either 0, indicating success (in which case "done." will
                be output) or 1 (or otherwise non-zero) indicating failure
                (in which case "failed." will be output). If a string is
                provided as the second argument, it will be included in the
                message, eg:

                <example compact="compact">
$ log_action_begin_msg "Doing something useful"; log_action_end_msg 0 "extra info"
Doing something useful...done (extra info).
                </example>
              </p>
            </item>

            <item>
              <p>When the configuration is reloaded</p>

              <p>
                When a daemon is forced to reload its configuration
                files you should use the following format:
                <example compact="compact">
Reloading <var>description</var> configuration...done.
                </example>
                where <var>description</var> is the same as in the
                daemon starting message.
              </p>
            </item>

            <item>
              <p>When the <tt>status</tt> action is called</p>

              <p>
                When the <tt>status</tt> action is called and the
                service is running, print:
                <example compact="compact">
<var>Service</var> is running.
                </example>
                When the service is not running, print:
                <example compact="compact">
<var>Service</var> is not running.
                </example>
              </p>
            </item>
          </list>
        </p>
        <p>
          These functions allow a special "fancy output" format which
          will prefix the lines with a <tt>[....]</tt> and, when a daemon
          or command succeeds or fails, fill that box in with a colored
          <tt>[ ok ]</tt>, <tt>[warn]</tt> or <tt>[FAIL]</tt>, making it
          easier for admins to see potential problems at a glance.
        </p>
         </sect1>


         <sect1>
          <heading>Miscellaneous Notes</heading>
          <p>
            Be careful of using <tt>set -e</tt> in <file>init.d</file>
            scripts.  Writing correct <file>init.d</file> scripts requires
            accepting various error exit statuses when daemons are already
            running or already stopped without aborting
            the <file>init.d</file> script, and common <file>init.d</file>
            function libraries are not safe to call with <tt>set -e</tt>
            in effect<footnote>
              <tt>/lib/lsb/init-functions</tt>, which assists in writing
              LSB-compliant init scripts, may fail if <tt>set -e</tt> is
              in effect and echoing status messages to the console fails,
              for example.
            </footnote>.  For <tt>init.d</tt> scripts, it's often easier
            to not use <tt>set -e</tt> and instead check the result of
            each command separately.
          </p>

          <p>
            The <file>/etc/init.d</file> scripts must be treated as
            configuration files, either (if they are present in the
            package, that is, in the .deb file) by marking them as
            <tt>conffile</tt>s, or, (if they do not exist in the .deb)
            by managing them correctly in the maintainer scripts (see
            <url id="https://www.debian.org/doc/debian-policy/ch-files.html#s-config-files" name="Configuration files">).  This is important since we want
            to give the local system administrator the chance to adapt
            the scripts to the local system, e.g., to disable a
            service without de-installing the package, or to specify
            some special command line options when starting a service,
            while making sure their changes aren't lost during the next
            package upgrade.
          </p>

          <p>
            These scripts should not fail obscurely when the
            configuration files remain but the package has been
            removed, as configuration files remain on the system after
            the package has been removed.  Only when <prgn>dpkg</prgn>
            is executed with the <tt>--purge</tt> option will
            configuration files be removed.  In particular, as the
            <file>/etc/init.d/<var>package</var></file> script itself is
            usually a <tt>conffile</tt>, it will remain on the system
            if the package is removed but not purged.  Therefore, you
            should include a <tt>test</tt> statement at the top of the
            script, like this:
            <example compact="compact">
test -f <var>program-executed-later-in-script</var> || exit 0
            </example>
          </p>

          <p>
            Files and directories under <file>/run</file>, including ones
            referred to via the compatibility paths <file>/var/run</file>
            and <file>/var/lock</file>, are normally stored on a temporary
            filesystem and are normally not persistent across a reboot.
            The <file>init.d</file> scripts must handle this correctly.
            This will typically mean creating any required subdirectories
            dynamically when the <file>init.d</file> script is run.
            See <url id="https://www.debian.org/doc/debian-policy/ch-opersys.html#s-fhs-run" name="Debian policy on /run"> for more information.
          </p>

          <p>
            There used to be another directory, <file>/etc/rc.boot</file>,
            which contained scripts which were run once per machine
            boot. This has been deprecated in favour of links from
            <file>/etc/rcS.d</file> to files in <file>/etc/init.d</file>.
            Packages must not place files in <file>/etc/rc.boot</file>.
          </p>
        </sect1>
        <sect1>
          <heading>Example</heading>

          <p>
            An example on which you can base your
            <file>/etc/init.d</file> scripts is found in
            <file>/etc/init.d/skeleton</file>.
          </p>
        </sect1>
    </sect>

    <sect id="upstartjobs">
      <heading>upstart job files</heading>
          <p>
            Packages may integrate with the <prgn>upstart</prgn> event-based
            boot system by installing job files in the
            <file>/etc/init</file> directory.
          </p>

          <p>
            SysV init scripts for which
            an equivalent upstart job is available must query the output of
            the command <prgn>initctl version</prgn> for the string
            <tt>upstart</tt> and avoid running in favor of the native
            upstart job, using a test such as this:
            <example compact="compact">
if [ "$1" = start ] && which initctl >/dev/null && initctl version | grep -q upstart
then
        exit 1
fi
            </example>
          </p>

          <p>
            Because packages shipping upstart jobs may be installed on
            systems that are not using upstart, maintainer scripts must
            still use the common <prgn>update-rc.d</prgn> and
            <prgn>invoke-rc.d</prgn> interfaces for configuring runlevels
            and for starting and stopping services.  These maintainer
            scripts must not call the upstart <prgn>start</prgn>,
            <prgn>restart</prgn>, <prgn>reload</prgn>, or <prgn>stop</prgn>
            interfaces directly.  Instead, implementations of
            <prgn>invoke-rc.d</prgn> must detect when upstart is running and
            when an upstart job with the same name as an init script is
            present, and perform the requested action using the upstart job
            instead of the init script.
          </p>

          <p>
            Dependency-based boot managers for SysV init scripts, such as
            <prgn>startpar</prgn>, may avoid running a given init script
            entirely when an equivalent upstart job is present, to avoid
            unnecessary forking of no-op init scripts.  In this case, the
            boot manager should integrate with upstart to detect when the
            upstart job in question is started or stopped to know when the
            dependency has been satisfied.
         </p>
    </sect>
  </chapt>

  <chapt id="initsysmaint">
    <heading>Maintaining an Init System</heading>
    <sect id="sbininit">
      <heading>Providing /sbin/init</heading>
      <p>FIXME: Packages providing an init system should provide a binary in
      /lib/$package/... , invokable via init=/lib/$package/... on the kernel
      command line.
      </p>
    </sect>
    <sect id="boothooks">
      <heading>Hooking into the boot system</heading>
    </sect>
    <sect id="policyhooks">
      <heading>Hooking into the init policy system</heading>
      <p>(Covers update-rc.d, invoke-rc.d, policy-rc.d, /usr/sbin/service, etc)</p>
      <p>
      FIXME: As far as I can tell, /usr/sbin/service doesn't actually support
      "hooking"; it just lives in sysvinit-utils and has specific support for
      sysvinit, upstart, and systemd.
      </p>
      <p>Packages providing an implentation of policy-rc.d must use the alternatives
      system to do so.</p>
    <sect id="initpkgnames">
      <heading>Related packages</heading>
    </sect>
    <sect>
      <heading>fixme</heading>
      <p>advice about compatibility with extended systemd services
      (systemd-shim, logind, ...?)
      </p>
    </sect>
  </chapt>

</book>
